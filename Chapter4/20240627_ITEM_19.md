상속을 고려한 설계와 문서화

- **상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 함**
    - 클래스의 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수도 있음
    - 마침 호출되는 메서드가 재정의 가능 메서드라면 그 사실을 호출하는 메서드의 API 설명에 적시해야 함
    - 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 함
- API 문서의 메서드 설명 끝에서 종종 Implementation Requirements로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳
    - 메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해줌
    - 하지만, 좋은 API 문서란 ‘어떻게’가 아닌 ‘무엇’을 하는지를 설명해야 한다는 격언과 대치됨
        - 상속이 캡슐화를 해치기 때문에 일어남
        - 안전하게 상속할 수 있도록 하려면 (상속이 아니면 기술하지 않아도 될) 내부 구현 방식을 설명해야만 함
    

내부 메커니즘을 문서로 남기는 것만이 상속을 위한 설계의 전부는 아님

효율적인 하위 클래스를 큰 어려움 없이 만드려면 **클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있음**

- protected로 노출해야 하는 메서드를 선별하는 방법
    - 심사숙고해서 잘 예측해본 다음, 실제 하위 클래스를 만들어 시험해보는 것이 최선
    - protected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 한 적어야 함
    - **상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 `유일` 하다**
        - 꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리가 확연히 드러남
        - 전혀 쓰이지 않는 protected 멤버는 사실 private여야 할 가능성이 큼
- 널리 쓰일 클래스를 상속용으로 설계한다면 문서화한 내부 사용 패턴과, protected 메서드와 필드를 구현하면서 선택한 결정에 영원히 책임져야 함
    - **그러니 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 함**

**상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안됨**

- 이 규칙을 어기면 프로그램이 오동작 함
- 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출됨
    - 이때 그 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않음

```java
public class Super {
	public Super() {
		oveerrideMe();
	}
	
	public void overrideMe() {
		
	}
	
}

// 하위 클래스의 코드로 overrideMe 재정의
public final class Sub extends Super {
	private final Instant instant;
	
	Sub() {
		instant = Instant.now();
	}
	
	// 재정의 가능 메서드. 상위 클래스의 생성자가 호출
	@Override
	public void overrideMe() {
		System.out.println(instant);
	}
	
	public static void main(String[] args) {
		Sub sub = new Sub();
		sub.overrideMe();
	}
	
}
```

- 첫 번째는 null을 출력
    - 상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴스 필드를 초기화하기도 전에 overrideMe 를 호출하기 때문
- final 필드의 상태가 이 프로그램에서는 두 가지(정상이라면 하나)
    - ovverideMe에서 instant 객체의 메서드를 호출하려 한다면 상위 클래스의 생성자가 overrideMe를 호출할 때 NullPointerException을 던지게 됨
    - 예외를 던지지 않은 이유는 pritnln이 null 입력도 받아들이기 때문
    
    cf) private, final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 됨
    

Cloneable과 Serializable 둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 건 엄청난 부담을 줌

- clone과 readObject 메서드는 생성자와 비슷한 효과를 냄
    
    (새로운 객체를 만듦)
    
    - 따라서 상속용 클래스에서 Cloneable이나 Serialzable을 구현할지 정해야 한다면, 제약도 생성자와 비슷하다는 점에 주의
    - 즉, **clone과 readObject 모두 직간접적으로 재정의 가능 메서드를 호출해서는 안됨**
        - readObject
            - 하위 클래스의 상태가 미쳐 다 역직렬화되기 전에 재정의한 메서드부터 호출하게 됨
        - clone
            - 하위 클래스의 clone 메서드가 복제본의 상태를 수정하기 전에 재정의한 메서드를 호출
            - 원본 객체에도 피해를 줄 수 있음
    - Serialzable을 구현한 상속용 클래스가 readResolve나 wirteReplace 메서드를 갖는다면 protected로 선언해야 함
        - priavte로 선언하면 하위 클래스에서 무시되기 때문

**클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약이 상당함**

일반적인 구체 클래스의 경우 **상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이 좋음**

- 상속을 금지하는 방법은 두 가지
    - 클래스를 final로 선언
    - 모든 생성자를 private이나 package-private로 선언하고 public 정적 팩토리 생성
- 구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기에 상당히 불편해짐
    - 이런 클래스를 상속할 때에는 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남겨야 함
        
        → 재정의 가능 메서드를 호출하는 자기 사용 코드를 완벽히 제거하라는 말
        
- 클래스의 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 기계적인 방법
    - 각각의 재정의 가능 메서드는 자신의 본문 코드를 private ‘도우미 메서드’로 옮기고 이 도우미 세더를 호출하도록 수정
    - 이후 재정의 가능 메서드를 호출하는 다른 코드들도 모두 이 도미 메서드를 직접 호출하도록 수정