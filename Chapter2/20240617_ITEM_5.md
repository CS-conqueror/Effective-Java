# ITEM 5) 자원을 직접 명시하지말고 의존 객체 주입을 사용하라

다수의 클래스는 하나 이상의 자원에 의존한다. (ex: 맞춤법 검사기는 dictionary 자원에 의존)

이러한 자원 의존적인 클래스를 구현하는 방법에는 아래와 같은 방법이 있다.

</br>

- 정적 유틸리티 클래스를 이용하는 잘못된 방법
```
public class MyClass {
		private static final ResourceType resource;
		private MyClass() {}  // 인스턴스화 방지
		//...
}
```

- 싱글턴을 사용한 잘못된 방법
```
public class MyClass {
		private final ResourceType resource;
		private MyClass(...) {}
		public static MyClass INSTANCE = new MyClass(...);  // 싱글턴
		//...
}
```
</br>

`두 방법이 잘못된 이유`

- 유연하지 않고 테스트하기 어렵다.
- 자원을 하나만 사용하기 때문에 별도의 추가적인 자원을 이용한 기능을 구현하는데 적합하지 않다.
- final 한정자를 제거하고 다른 사전으로 교체하는 메서드를 추가하여 보완하더라도, 이 방법은 오류를 내기 쉬우며 멀티스레드 환경에서는 쓸 수 없다.

</br>

> 사용하는 자원에 따라 동작이 달라지는 클래스는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.

</br>
</br>
</br>

## 의존 객체 주입 패턴
인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식으로, 자원 팩터리를 넘겨주는 등의 방식으로 변형할 수 있다

```
public class MyClass {
		private ResourceType resource;
		// ResourceType에 의존하는 Myclass 클래스
		public MyClass(ResourceType resource) {  // 의존 객체 주입
				this.resource = Objects.requireNonNull(resource);
		}
		//...
}
```

- 장점
    - 클래스의 유연성, 재사용성, 테스트 용이성을 엄청나게 개선한다.
    - 자원의 개수나 의존 관계에 영향을 받지 않는다.
    - 불변을 보장하여 해당 자원을 사용하는 여러 클라이언트가 안전하게 공유할 수 있다.
- 단점
    - 의존성이 수 천 개나 되는 대형 프로젝트에서는 코드가 복잡해질 수 있다.
        
        → 수천 개의 클래스가 서로 다양한 자원에 의존할때, 이를 모두 생성자를 통해 주입해야 한다면, 클래스 간의 의존관계를 파악하고 관리하는데 어렵다. 
        
        → Spring 같은 의존 객체 주입 프레임워크를 이용하면 해소 가능

</br>

>클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다.
이 자원들을 클래스가 직접 만들게 해서도 안된다.
대신 필요한 자원을 생성자에 넘겨주자.
의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 기막히게 개선해준다.
